<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link rel="apple-touch-icon" href="/icon.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Lock-In">
<title>Lock-In Tool</title>
<style>
:root {
  --bg: #111827; --card: #1f2937; --muted: #94a3b8; --accent: #22c55e;
  --glass: rgba(255, 255, 255, .05); --border: rgba(255, 255, 255, .1);
  --error: #ef4444;
}

html, body {
  height: 100%; margin: 0; font-family: Inter, system-ui, sans-serif;
  color: #f8fafc; background: var(--bg); overscroll-behavior-y: none;
}

body { 
  display: flex; justify-content: center; align-items: flex-start; 
  padding: 16px; box-sizing: border-box;
  overflow-x: hidden;
}

body::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 0;
  opacity: 0.32;
  background:
    radial-gradient(70% 55% at 0% 0%, rgba(0, 0, 0, 0.56), rgba(0, 0, 0, 0)),
    radial-gradient(70% 55% at 100% 0%, rgba(0, 0, 0, 0.56), rgba(0, 0, 0, 0)),
    radial-gradient(70% 55% at 0% 100%, rgba(0, 0, 0, 0.56), rgba(0, 0, 0, 0)),
    radial-gradient(70% 55% at 100% 100%, rgba(0, 0, 0, 0.56), rgba(0, 0, 0, 0));
}

.app {
  max-width: 600px; width: 100%; margin: 10px auto; padding: 24px;
  border-radius: 16px; background: var(--card);
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  box-sizing: border-box; display: flex; flex-direction: column;
  position: relative;
  z-index: 1;
  overflow: hidden;
}

.app::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 0;
  opacity: 0.28;
  background:
    radial-gradient(68% 52% at 0% 0%, rgba(0, 0, 0, 0.48), rgba(0, 0, 0, 0)),
    radial-gradient(68% 52% at 100% 0%, rgba(0, 0, 0, 0.48), rgba(0, 0, 0, 0)),
    radial-gradient(68% 52% at 0% 100%, rgba(0, 0, 0, 0.48), rgba(0, 0, 0, 0)),
    radial-gradient(68% 52% at 100% 100%, rgba(0, 0, 0, 0.48), rgba(0, 0, 0, 0));
}

.app > * {
  position: relative;
  z-index: 1;
}

.screen { display: none; }
.screen.active { display: block; }
.screen-focus.active {
  display: flex;
  position: fixed;
  inset: 0;
  z-index: 5;
  background: var(--bg);
  padding: 24px 20px;
  box-sizing: border-box;
  overflow: hidden;
}

.screen-focus.active::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 0;
  opacity: 0.28;
  background:
    radial-gradient(68% 52% at 0% 0%, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0)),
    radial-gradient(68% 52% at 100% 0%, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0)),
    radial-gradient(68% 52% at 0% 100%, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0)),
    radial-gradient(68% 52% at 100% 100%, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));
}

.screen-focus.active > * {
  position: relative;
  z-index: 1;
}

.focus-shell {
  width: 100%;
  min-height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 18px;
  padding-bottom: max(10px, env(safe-area-inset-bottom));
}

.focus-stack {
  width: 100%;
  max-width: 520px;
  min-height: 320px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 12px;
}

.focus-item {
  text-align: center;
  border-radius: 22px;
  padding: 14px 18px;
  border: 1px solid rgba(255, 255, 255, 0.08);
  background: rgba(255, 255, 255, 0.04);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  overflow-wrap: anywhere;
  word-break: break-word;
  transform: translate3d(0, 0, 0);
  will-change: transform, opacity;
  transition: transform 450ms ease, opacity 450ms ease;
}

.focus-item-prev {
  opacity: 0.4;
  transform: translate3d(0, -8px, 0);
  font-size: 15px;
  font-weight: 500;
}

.focus-item-next {
  opacity: 0.65;
  transform: translate3d(0, 8px, 0);
  font-size: 20px;
  font-weight: 650;
}

.focus-item-current {
  opacity: 1;
  transform: translate3d(0, 0, 0);
  border-color: rgba(255, 255, 255, 0.14);
  background: rgba(255, 255, 255, 0.08);
}

.focus-current-task {
  font-size: 48px;
  font-weight: 800;
  line-height: 1.1;
  overflow-wrap: anywhere;
  word-break: break-word;
}

.focus-current-timer {
  margin-top: 8px;
  font-size: 40px;
  font-weight: 800;
  font-variant-numeric: tabular-nums;
}

.focus-item-completing {
  opacity: 0.18;
  transform: translateY(42px);
}

.focus-actions {
  width: 100%;
  max-width: 380px;
  display: flex;
  flex-direction: column;
  margin-top: 8px;
  padding-bottom: max(14px, env(safe-area-inset-bottom));
  gap: 12px;
}

.focus-lock-switch {
  width: 100%;
  height: 70px;
  margin: 0 auto;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  cursor: pointer;
  touch-action: pan-y;
}

.focus-lock-switch input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
}

.focus-lock-track {
  width: 100%;
  height: 70px;
  border-radius: 999px;
  background: #ef4444;
  border: 1px solid rgba(0, 0, 0, 0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  transition: background-color 300ms ease-in-out, transform 300ms ease-in-out;
}

.focus-lock-knob {
  position: absolute;
  top: 8px;
  left: 8px;
  width: 54px;
  height: 54px;
  border-radius: 999px;
  background: #f8fafc;
  box-shadow: 0 6px 14px rgba(0, 0, 0, 0.28);
  transition: left 300ms ease-in-out;
}

.focus-lock-icon {
  position: absolute;
  width: 30px;
  height: 30px;
  color: #111827;
  fill: currentColor;
  transition: opacity 300ms ease-in-out, transform 300ms ease-in-out;
}

.focus-lock-icon svg {
  width: 30px;
  height: 30px;
  display: block;
}

.focus-lock-icon-unlock {
  right: 20px;
  opacity: 1;
  transform: scale(1);
}

.focus-lock-icon-lock {
  left: 20px;
  opacity: 0.25;
  transform: scale(0.92);
}

.focus-lock-switch input:checked + .focus-lock-track {
  background: var(--accent);
  transform: scale(1.01);
}

.focus-lock-switch input:checked + .focus-lock-track .focus-lock-knob {
  left: calc(100% - 8px - 54px);
}

.focus-lock-switch input:checked + .focus-lock-track .focus-lock-icon-unlock {
  opacity: 0.2;
  transform: scale(0.92);
}

.focus-lock-switch input:checked + .focus-lock-track .focus-lock-icon-lock {
  opacity: 1;
  transform: scale(1);
}

.focus-complete-wrap {
  width: 100%;
  transition: transform 450ms ease, opacity 450ms ease;
}

.focus-complete-wrap.focus-complete-firing {
  transform: translateY(6px) scale(0.98);
  opacity: 0.75;
}

.focus-complete-btn {
  width: 100%;
  height: 70px;
  padding: 0 20px;
  border-radius: 999px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
}

.focus-manage-btn {
  width: 100%;
  height: 62px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: #111827;
  color: #f8fafc;
  transition: opacity 220ms ease-in-out, transform 220ms ease-in-out;
}

.focus-manage-slot {
  width: 100%;
  height: 62px;
}

.focus-manage-btn.is-visible {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0);
}

.focus-manage-btn.is-hidden {
  opacity: 0;
  pointer-events: none;
  transform: translateY(-2px);
}

.focus-timers {
  width: 100%;
  max-width: 420px;
  text-align: center;
}

.focus-stopwatch-main {
  margin-top: 0;
  min-height: 64px;
  font-size: 64px;
  font-weight: 800;
  font-variant-numeric: tabular-nums;
  line-height: 1;
}

.focus-remaining-sub {
  margin-top: 8px;
  font-size: 13px;
  color: var(--muted);
  font-variant-numeric: tabular-nums;
}

.focus-stack.completing .focus-item {
  transition: transform 300ms ease-in-out;
}

.focus-item-complete-out {
  transform: translate3d(0, -78px, 0) scale(0.94);
}

.focus-item-promote {
  transform: translate3d(0, -34px, 0) scale(1.06);
}

.focus-item-shift-up {
  transform: translate3d(0, -28px, 0);
}

.focus-item-next-shift {
  transform: translate3d(0, -28px, 0);
}

.focus-entry-overlay {
  position: fixed;
  inset: 0;
  background: rgba(17, 24, 39, 0.55);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  z-index: 950;
  opacity: 0;
  pointer-events: none;
  transition: opacity 170ms ease-in-out;
}

.focus-entry-overlay.active {
  opacity: 1;
  pointer-events: auto;
}

header { display: flex; flex-direction: column; margin-bottom: 24px; }
h1 { margin: 0; font-size: 24px; color: var(--accent); }
.subtitle { font-size: 13px; color: var(--muted); margin-top: 4px; }

button {
  font-size: 16px; padding: 12px; border-radius: 10px;
  border: 1px solid var(--border); background: #111827; color: inherit;
  touch-action: manipulation; cursor: pointer;
  transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), background-color 0.2s;
  outline: none;
}
button:active { transform: scale(1.08); filter: brightness(1.2); }
input {
  font-size: 16px; padding: 12px; border-radius: 10px;
  border: 1px solid var(--border); background: #111827; color: inherit;
  width: 100%; box-sizing: border-box;
}

.main-add-container {
  margin-bottom: 16px;
  display: flex;
  gap: 10px;
  width: 100%;
}

.btn-add-task {
  flex: 4 1 0;
  width: auto;
  background: var(--accent);
  color: #000;
  font-weight: 700;
  border: none;
  font-size: 30px;
  line-height: 1;
}

.btn-end-icon {
  flex: 1 1 0;
  width: auto;
  border: 1px solid var(--error);
  color: var(--error);
  background: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  font-weight: 800;
}

.task-list { display: grid; gap: 12px; margin-bottom: 12px; }
.task {
  padding: 16px; border-radius: 12px; border: 1px solid var(--border);
  background: #111827; display: flex; justify-content: space-between;
  align-items: center; gap: 12px; transition: all 0.2s ease; overflow: hidden;
  cursor: grab; user-select: none;
}

.task.task-dragging {
  opacity: 0.6;
}

.task-drop-placeholder {
  height: 64px;
  border-radius: 12px;
  border: 1px dashed rgba(148, 163, 184, 0.5);
  background: rgba(148, 163, 184, 0.08);
}

.task-content {
  flex: 1;
  min-width: 0;
  overflow-wrap: anywhere;
  word-break: break-word;
}
.task.selected { border: 2px solid var(--accent); box-shadow: 0 0 10px rgba(34, 197, 94, 0.2); }
.task.done { background: #1f2937; border-color: #374151; color: #64748b; text-decoration: line-through; opacity: 0.7; }

.timer-grid {
  display: none;
  margin-top: 18px;
  margin-bottom: 10px;
  padding: 0 2px;
  box-sizing: border-box;
}
.timer-info-row {
  width: 100%;
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  gap: 10px;
  padding: 12px 14px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--glass);
  box-sizing: border-box;
}
.timer-info-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}
.timer-info-label {
  font-size: 11px;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.4px;
}
.timer-info-divider {
  color: #64748b;
  font-size: 16px;
  line-height: 1;
}
.time { font-size: 28px; font-weight: 700; font-variant-numeric: tabular-nums; }

.actions {
  display: flex;
  gap: 0;
  margin-top: 14px;
  margin-bottom: 24px;
  width: 100%;
  position: sticky;
  bottom: 16px;
  z-index: 2;
}
.actions button { width: 100%; flex: none; padding: 16px; font-size: 18px; }
button.primary { background: var(--accent); border: none; color: #000; font-weight: 700; }

.overlay {
  position: fixed; inset: 0; background: rgba(0, 0, 0, 0.9);
  display: none; align-items: center; justify-content: center; z-index: 1000; padding: 20px;
  backdrop-filter: blur(4px);
}
.overlay-card { background: var(--card); padding: 24px; border-radius: 16px; width: 100%; max-width: 440px; text-align: center; box-sizing: border-box; }

.hero-title { font-size: 48px; font-weight: 900; letter-spacing: -3px; color: #fff; font-style: italic; margin-bottom: 10px; }

.insights-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin: 20px 0; }
.insight-item { background: #111827; padding: 16px; border-radius: 12px; border: 1px solid var(--border); text-align: left; position: relative; }
.insight-label { font-size: 10px; color: var(--muted); text-transform: uppercase; font-weight: 700; display: flex; align-items: center; gap: 6px; }
.insight-val { font-size: 22px; font-weight: 800; margin-top: 6px; color: #fff; }

.info-wrapper { position: relative; display: inline-flex; align-items: center; }
.info-icon { 
  cursor: pointer; color: var(--accent); font-size: 10px; 
  background: rgba(34, 197, 94, 0.1); width: 14px; height: 14px; 
  display: flex; align-items: center; justify-content: center; 
  border-radius: 50%; border: 1px solid rgba(34, 197, 94, 0.3);
  font-weight: bold;
}

/* Bottom Sheet */
.bottom-sheet {
  position: fixed; bottom: -100%; left: 0; right: 0;
  background: var(--card); border-top: 1px solid var(--border);
  border-radius: 20px 20px 0 0; padding: 24px; z-index: 2000;
  transition: bottom 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 -10px 40px rgba(0,0,0,0.5);
}
.bottom-sheet.active { bottom: 0; }
.sheet-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.6);
  display: none; z-index: 1999; backdrop-filter: blur(2px);
}
.sheet-overlay.active { display: block; }
.handle { width: 40px; height: 4px; background: #374151; border-radius: 2px; margin: -12px auto 20px auto; }

/* Modal New UI Components */
.setting-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; text-align: left; }
.setting-label { font-size: 12px; font-weight: 700; color: var(--muted); text-transform: uppercase; }

.editor-time-row {
  margin: 10px 0 16px 0;
}

.smart-time-wrap {
  position: relative;
}

#smartTimeInput {
  color: #6b7280;
  caret-color: #9ca3af;
  font-size: 28px;
  font-family: monospace;
  letter-spacing: 2px;
  text-align: center;
  position: relative;
  background: #111827;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  border: 1px solid var(--border);
  outline: none;
}

.smart-time-mask {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  font-size: 28px;
  font-family: monospace;
  letter-spacing: 2px;
  line-height: 1;
}

.smart-time-mask .entered {
  color: var(--accent);
}

.smart-time-mask .placeholder {
  color: transparent;
}

.editor-split-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 16px;
}

.editor-actions-row {
  display: grid;
  grid-template-columns: 1fr 2fr 1fr;
  gap: 10px;
  margin-top: 18px;
}

.editor-actions-row.add-mode {
  grid-template-columns: 1fr 3fr;
}

.editor-actions-row.edit-mode {
  grid-template-columns: 1fr 2fr 1fr;
}

.editor-actions-row.add-mode .editor-delete-btn {
  display: none;
}

.editor-actions-row.edit-mode .editor-delete-btn {
  display: flex;
}

.editor-icon-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
}

.editor-confirm-btn {
  font-weight: 800;
  min-height: 48px;
}

#modalTitle {
  margin-top: 0;
  margin-bottom: 16px;
  min-height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-mode-icon {
  width: 22px;
  height: 22px;
  display: block;
  color: var(--muted);
}

.editor-delete-btn {
  border: 1px solid transparent;
  background: transparent;
  color: var(--muted);
}

.editor-delete-btn.is-disabled {
  opacity: 0.4;
  pointer-events: none;
  border-color: transparent;
  color: var(--muted);
}

.editor-delete-btn.is-enabled {
  opacity: 1;
  pointer-events: auto;
  border-color: #EF4444;
  color: #EF4444;
}

.editor-delete-btn.is-enabled:hover {
  background: rgba(239, 68, 68, 0.08);
}

.ui-icon {
  width: 20px;
  height: 20px;
  display: block;
}

#workModeSelect {
  width: 100%;
  padding: 10px 34px 10px 12px;
  border-radius: 10px;
  background: #111827;
  color: #fff;
  border: 1px solid var(--border);
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none'%3E%3Cpath d='M6 9l6 6 6-6' stroke='%2394a3b8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 12px center;
  background-size: 14px 14px;
  outline: none;
}

#workModeSelect:focus {
  border-color: #22c55e;
  box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2);
  outline: none;
}

#workModeSelect:focus-visible {
  outline: none;
}

#workModeSelect::-ms-expand {
  display: none;
}

* {
  -webkit-user-select: none;
  user-select: none;
}

#modalTaskName {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  border: 1px solid var(--border);
  outline: none;
  -webkit-user-select: text;
  user-select: text;
}

#modalTaskName:focus,
#smartTimeInput:focus {
  border-color: #22c55e;
  box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2);
  outline: none;
}

#modalTaskName:focus-visible,
#smartTimeInput:focus-visible {
  outline: none;
}

.pulse-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 6px;
  border-radius: 999px;
  background: rgba(148, 163, 184, 0.25);
  outline: none;
  margin-top: 8px;
}

.pulse-slider::-webkit-slider-runnable-track {
  height: 6px;
  border-radius: 999px;
  background: linear-gradient(90deg, #374151 0%, #22c55e 100%);
}

.pulse-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 999px;
  background: #f8fafc;
  border: 2px solid #22c55e;
  margin-top: -6px;
  transition: transform 120ms ease;
}

.pulse-slider::-webkit-slider-thumb:active {
  transform: scale(1.08);
}

.pulse-slider::-moz-range-track {
  height: 6px;
  border-radius: 999px;
  background: linear-gradient(90deg, #374151 0%, #22c55e 100%);
}

.pulse-slider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 999px;
  background: #f8fafc;
  border: 2px solid #22c55e;
}

.toggle-switch {
  position: relative; display: inline-block; width: 50px; height: 26px;
}
.toggle-switch input { opacity: 0; width: 0; height: 0; }
.slider {
  position: absolute; cursor: pointer; inset: 0; background-color: #374151;
  transition: .4s; border-radius: 34px;
}
.slider:before {
  position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px;
  background-color: white; transition: .4s; border-radius: 50%;
}
input:checked + .slider { background-color: var(--accent); }
input:checked + .slider:before { transform: translateX(24px); }

.range-picker { width: 100%; margin: 8px 0; accent-color: var(--accent); }

.task-breakdown { text-align: left; max-height: 180px; overflow-y: auto; margin-top: 20px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; }
.breakdown-row { display: flex; justify-content: space-between; font-size: 13px; padding: 10px 0; border-bottom: 1px solid var(--border); }

footer { margin-top: auto; padding-top: 16px; border-top: 1px solid var(--border); text-align: center; font-size: 11px; color: var(--muted); }

.smart-picker { margin: 10px 0 20px 0; }
.smart-picker input {
  width: 100%; height: 56px; text-align: center; font-size: 28px; 
  font-family: monospace; letter-spacing: 2px;
  border: 2px solid var(--accent); background: #111827; color: var(--accent);
  border-radius: 12px;
}


#resBreakdown td, #resBreakdown th {
  padding: 8px;
  border-bottom: 1px solid var(--border);
}

#resBreakdown tr:hover {
  background: rgba(255,255,255,0.05);
}

#pulsePopup {
  background: rgba(17, 24, 39, 0.72);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  z-index: 1800;
}

#pulseTapCard {
  width: min(82vw, 320px);
  height: 160px;
  position: relative;
  overflow: hidden;

  border-radius: 22px;
  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 34px;
  font-weight: 900;
  letter-spacing: 1px;

  color: #000;
  cursor: pointer;
  user-select: none;

  transition:
    background-color 280ms ease,
    box-shadow 280ms ease,
    transform 250ms ease;

  box-shadow:
    0 20px 60px rgba(0,0,0,0.6);
}

/* Pulse beat stays subtle */
#pulseTapCard:active {
  transform: scale(1.05);
}

#pulseFillLayer {
  position: absolute;
  inset: auto 0 0 0;
  height: 0%;
  z-index: 0;
  background: #22c55e;
}

#pulseFillLayer.active {
  animation: pulseFillRise 60s linear forwards;
}

#pulseTapText {
  position: relative;
  z-index: 1;
}

/* COLOR STATES */
.pulse-green {
  box-shadow: 0 0 60px rgba(34,197,94,0.6);
}

.pulse-yellow {
  box-shadow: 0 0 60px rgba(234,179,8,0.6);
}

.pulse-orange {
  box-shadow: 0 0 60px rgba(249,115,22,0.6);
}

.pulse-red {
  box-shadow: 0 0 60px rgba(239,68,68,0.6);
}

@keyframes pulseFillRise {
  0% {
    height: 0%;
    background: #22c55e;
  }
  50% {
    background: #eab308;
  }
  100% {
    height: 100%;
    background: #ef4444;
  }
}


@keyframes pulseBeat {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.08); }
  100% { transform: scale(1); }
}

.app.blurred {
  filter: blur(6px);
  pointer-events: none;
}


</style>
</head>
<body>

<div class="app" id="app">
  <section id="focusScreen" class="screen screen-focus">
    <div class="focus-shell">
      <div id="focusStack" class="focus-stack"></div>
      <div class="focus-timers">
        <div id="focusStopwatchMain" class="focus-stopwatch-main">00:00</div>
        <div id="focusRemainingSub" class="focus-remaining-sub">remaining 00:00</div>
      </div>
      <div class="focus-actions" id="focusActions">
        <div class="focus-lock-switch" id="focusLockSwitch">
          <input type="checkbox" id="focusLockToggle">
          <span class="focus-lock-track">
            <span class="focus-lock-icon focus-lock-icon-unlock" aria-hidden="true">
              <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <path d="M50,18A19.9,19.9,0,0,0,30,38v8a8,8,0,0,0-8,8V74a8,8,0,0,0,8,8H70a8,8,0,0,0,8-8V54a8,8,0,0,0-8-8H38V38a12,12,0,0,1,23.6-3,4,4,0,1,0,7.8-2A20.1,20.1,0,0,0,50,18Z"></path>
              </svg>
            </span>
            <span class="focus-lock-icon focus-lock-icon-lock" aria-hidden="true">
              <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <path d="M30,46V38a20,20,0,0,1,40,0v8a8,8,0,0,1,8,8V74a8,8,0,0,1-8,8H30a8,8,0,0,1-8-8V54A8,8,0,0,1,30,46Zm32-8v8H38V38a12,12,0,0,1,24,0Z" fill-rule="evenodd"></path>
              </svg>
            </span>
            <span class="focus-lock-knob"></span>
          </span>
        </div>
        <div id="focusCompleteWrap" class="focus-complete-wrap">
          <button id="focusCompleteBtn" class="primary focus-complete-btn">Complete Task</button>
        </div>
        <div id="focusManageSlot" class="focus-manage-slot">
          <button id="focusManageBtn" class="focus-manage-btn is-visible">Manage</button>
        </div>
      </div>
    </div>
  </section>

  <section id="manageScreen" class="screen screen-manage active">
    <div class="main-add-container" id="addWrapper">
      <button class="btn-add-task" id="openAddModalBtn">+</button>
      <button id="endSessionBtn" class="btn-end-icon" aria-label="end session">
        <svg class="ui-icon" viewBox="0 0 600 600" fill="currentColor" aria-hidden="true">
          <path d="M130 0C58.672245 0 0 58.672245 0 130L0 470C0 541.32776 58.672245 600 130 600L301.57812 600C367.83331 600 423.13643 549.36696 430.67188 485L349.43555 485C343.32179 505.66026 324.7036 520 301.57812 520L130 520C101.60826 520 80 498.39174 80 470L80 130C80 101.60826 101.60826 80 130 80L301.57812 80C324.7036 80 343.32179 94.339739 349.43555 115L430.67188 115C423.13642 50.633038 367.83331 0 301.57812 0L130 0Z"></path>
          <path d="M476.86328 179.99911A40 40 0 0 0 448.57812 191.71395A40 40 0 0 0 448.57812 248.28427L460.29297 259.99911H163.72656A40 40 0 0 0 123.72656 299.99911A40 40 0 0 0 163.72656 339.99911H460.29297L448.57812 351.71395A40 40 0 0 0 448.57812 408.28427A40 40 0 0 0 505.14844 408.28427L577.93945 335.49325A40 40 0 0 0 600 299.99911A40 40 0 0 0 577.5293 264.09481L505.14844 191.71395A40 40 0 0 0 476.86328 179.99911Z"></path>
        </svg>
      </button>
    </div>

    <div id="taskList" class="task-list"></div>

    <div id="timerGrid" class="timer-grid">
      <div class="timer-info-row">
        <div class="timer-info-item">
          <div class="timer-info-label">Remaining Time</div>
          <div class="time" id="countdown">00:00:00</div>
        </div>
        <div class="timer-info-divider">|</div>
        <div class="timer-info-item">
          <div class="timer-info-label">Time Spent</div>
          <div class="time" id="stopwatch">00:00:00</div>
        </div>
      </div>
      <div id="stateText" style="display:none;">Idle</div>
    </div>

    <div class="actions" id="actionButtons">
      <button id="startBtn" class="primary">enter session</button>
    </div>

  </section>
</div>

<div id="focusEntryOverlay" class="focus-entry-overlay"></div>

<!-- Task Modal -->
<div id="taskEditorOverlay" class="overlay">
  <div class="overlay-card">
    <h3 id="modalTitle"></h3>
    <input id="modalTaskName" type="text" placeholder="task name">

    <div class="editor-time-row">
      <div class="setting-label" style="margin-bottom: 8px;">est. (hh:mm:ss)</div>
      <div class="smart-time-wrap">
        <input id="smartTimeInput" type="text" value="00:00:00" maxlength="8">
        <div id="smartTimeMask" class="smart-time-mask" aria-hidden="true"></div>
      </div>
    </div>

    <div class="editor-split-row">
      <div class="setting-row" style="flex-direction:column; align-items:flex-start; margin-bottom:0;">
        <div class="setting-label">Pulse Frequency: <span id="pulseRangeLabel" style="color:var(--accent)">OFF</span></div>
        <input id="pulseRange" class="pulse-slider" type="range" min="0" max="15" step="1" value="0">
      </div>
      <div class="setting-row" style="flex-direction:column; align-items:flex-start; margin-bottom:0;">
        <div class="setting-label">Work Mode</div>
        <select id="workModeSelect">
          <option value="">Blank</option>
          <option value="ONLINE">Online</option>
          <option value="OFFLINE">Offline</option>
        </select>
      </div>
    </div>

    <div class="editor-actions-row add-mode" id="editorActionsRow">
      <button id="cancelEditor" class="editor-icon-btn" style="background:#374151; border:none;" aria-label="cancel">
        <svg class="ui-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M6 6l12 12M18 6L6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
      </button>
      <button id="saveTaskBtn" class="editor-confirm-btn" style="background:var(--accent); color:#000; border:none;">Confirm</button>
      <button id="deleteTaskBtn" class="editor-icon-btn editor-delete-btn is-disabled" aria-label="delete">
        <svg class="ui-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M18 6L17.1991 18.0129C17.129 19.065 17.0939 19.5911 16.8667 19.99C16.6666 20.3412 16.3648 20.6235 16.0011 20.7998C15.588 21 15.0607 21 14.0062 21H9.99377C8.93927 21 8.41202 21 7.99889 20.7998C7.63517 20.6235 7.33339 20.3412 7.13332 19.99C6.90607 19.5911 6.871 19.065 6.80086 18.0129L6 6M4 6H20M16 6L15.7294 5.18807C15.4671 4.40125 15.3359 4.00784 15.0927 3.71698C14.8779 3.46013 14.6021 3.26132 14.2905 3.13878C13.9376 3 13.523 3 12.6936 3H11.3064C10.477 3 10.0624 3 9.70951 3.13878C9.39792 3.26132 9.12208 3.46013 8.90729 3.71698C8.66405 4.00784 8.53292 4.40125 8.27064 5.18807L8 6M14 10V17M10 10V17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
      </button>
    </div>
  </div>
</div>

<!-- Bottom Sheet -->
<div id="sheetOverlay" class="sheet-overlay" onclick="toggleSheet()"></div>
<div id="bottomSheet" class="bottom-sheet">
  <div class="handle"></div>
  <h4 id="sheetTitle" style="margin: 0 0 10px 0; color: var(--accent);">Formula Explanation</h4>
  <p id="sheetBody" style="font-size: 14px; color: var(--muted); line-height: 1.6; margin: 0;"></p>
  <button onclick="toggleSheet()" style="width: 100%; margin-top: 20px; background: var(--card); border: 1px solid var(--border);">Close</button>
</div>

<!-- Confirm End -->
<div id="confirmEndOverlay" class="overlay">
  <div class="overlay-card">
    <h3 style="margin-top:0">End Session?</h3>
    <p class="subtitle" style="margin-bottom: 24px;">This will stop all timers and calculate final insights.</p>
    <div style="display:flex; gap:10px;">
      <button onclick="closeConfirm()" style="flex:1; background:#374151; border:none;">Cancel</button>
      <button id="confirmEndBtn" style="flex:1; background:var(--error); color:#fff; border:none; font-weight: 700;">Yes, End Session</button>
    </div>
  </div>
</div>

<!-- Results -->
<div id="resultsOverlay" class="overlay">
  <div class="overlay-card" style="max-width: 500px;">
    <h3 style="margin:0; color:var(--accent)">Session Insights</h3>
    <div class="insights-grid">
      <div class="insight-item">
        <div class="insight-label">Session Duration</div>
        <div class="insight-val" id="resTotal">00:00:00</div>
      </div>
      <div class="insight-item">
        <div class="insight-label">Work Time</div>
        <div class="insight-val" id="resFocused">00:00:00</div>
      </div>
      <div class="insight-item">
        <div class="insight-label">Sidelined Time <span class="info-icon" onclick="openSheet('sidelined')">i</span></div>
        <div class="insight-val" id="resPaused">00:00:00</div>
      </div>
      <div class="insight-item">
        <div class="insight-label">Focus Ratio <span class="info-icon" onclick="openSheet('focus')">i</span></div>
        <div class="insight-val" id="resRatio">0%</div>
      </div>
    </div>

    <table id="resBreakdown" style="width:100%; border-collapse:collapse; font-size:13px;">
      <thead>
        <tr style="color:var(--muted); text-align:left;">
          <th>Task</th>
          <th>Mode</th>
          <th>Paused</th>
          <th>Work</th>
          <th>Total</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <button id="closeStatsBtn" class="primary" style="width:100%; margin-top:20px">New Session</button>
  </div>
</div>

<div id="taskTimelineOverlay" class="overlay">
  <div class="overlay-card" style="max-width:500px;">
    <h3>Task Timeline</h3>
    <table id="taskTimelineTable" style="width:100%; font-size:13px;">
      <thead>
        <tr>
          <th>Event</th>
          <th>Time</th>
          <th>Valid</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div style="display:flex; gap:10px; margin-top:15px;">
      <button id="backTaskTimelineBtn" style="flex:1; background:#374151; border:none;">Back</button>
      <button id="confirmTaskTimelineBtn" class="primary" style="flex:1;">Confirm</button>
    </div>
  </div>
</div>

<!-- Pulse Popup -->
<div id="pulsePopup" class="overlay">
  <div id="pulseTapCard" class="overlay-card" style="
    padding: 40px;
    font-size: 28px;
    font-weight: 900;
    text-align: center;
    cursor: pointer;
    user-select: none;
  ">
    <div id="pulseFillLayer"></div>
    <span id="pulseTapText">YOU THERE?</span>
  </div>
</div>

<script>
let tasks = [], current = null, paused = true, tick = null;
let sessionStartTimestamp = null, sessionEndTimestamp = null;
let totalFocusedSeconds = 0, editingIndex = null;
let sessionActive = false, taskRunning = false;

// ==== PULSE SYSTEM STATE (ADDITIVE) ====
let pulseTimer = null;
let pulseLog = [];
let lastPulseAt = null;
let activePulse = null;

let pendingSessionEnd = false;

let lastTickAt = null;
let uiScreen = 'manage';
let completionInFlight = false;
const FOCUS_COMPLETE_ANIM_MS = 450;
let focusEntryInFlight = false;
let timelineMode = 'view';
let timelineTaskIndex = null;
let completionPendingEndEntry = null;
let completionPendingEndTaskIndex = null;
let suppressTaskClick = false;
const dragState = {
  active: false,
  fromIndex: null,
  placeholder: null,
  draggedRow: null,
  pointerActive: false,
  pointerId: null,
  moved: false,
  startX: 0,
  startY: 0
};

const $ = id => document.getElementById(id);

function setScreen(mode) {
  const focus = $('focusScreen');
  const manage = $('manageScreen');
  if (!focus || !manage) return;
  const target = taskRunning ? 'focus' : mode;
  uiScreen = target === 'focus' ? 'focus' : 'manage';
  focus.classList.remove('active');
  manage.classList.remove('active');
  if (uiScreen === 'focus') {
    focus.classList.add('active');
  } else {
    manage.classList.add('active');
  }
}

function beginFocusEntryTransition() {
  if (focusEntryInFlight) return;
  const overlay = $('focusEntryOverlay');
  if (!overlay) {
    setScreen('focus');
    return;
  }
  focusEntryInFlight = true;
  overlay.classList.add('active');
  setTimeout(() => {
    setScreen('focus');
    overlay.classList.remove('active');
  }, 170);
  setTimeout(() => {
    focusEntryInFlight = false;
  }, 350);
}

function syncScreenRoute() {
  if (taskRunning) {
    if (uiScreen !== 'focus') {
      beginFocusEntryTransition();
      return;
    }
    setScreen('focus');
    return;
  }
  if (!sessionActive) {
    setScreen('manage');
    return;
  }
  setScreen(uiScreen);
}

function isOverlayVisible(id) {
  const el = $(id);
  return !!el && el.style.display === 'flex';
}

function clearPulseForTransition() {
  if (pulseTimer) { clearInterval(pulseTimer); pulseTimer = null; }
  if (activePulse) {
    if (activePulse.timeout) { clearTimeout(activePulse.timeout); activePulse.timeout = null; }
    if (activePulse.colorTimer) { clearInterval(activePulse.colorTimer); activePulse.colorTimer = null; }
  }
  $('pulseFillLayer')?.classList.remove('active');
  activePulse = null;
  $('pulsePopup').style.display = 'none';
  $('app')?.classList.remove('blurred');
}

function resetPulseScheduler() {
  if (pulseTimer) {
    clearInterval(pulseTimer);
    pulseTimer = null;
  }
}

function startPulseScheduler() {
  resetPulseScheduler();
  if (activePulse && activePulse.timeout) { clearTimeout(activePulse.timeout); activePulse.timeout = null; }
  if (!sessionActive || !taskRunning || current === null || !tasks[current]) return;
  const pulseMinutes = parseInt(tasks[current].pulse, 10) || 0;
  if (pulseMinutes < 5) return;
  pulseTimer = setInterval(() => {
    if (!sessionActive || !taskRunning || current === null || !tasks[current]) return;
    firePulse(tasks[current]);
  }, pulseMinutes * 60 * 1000);
}

function getDragPlaceholder() {
  if (!dragState.placeholder) {
    const ph = document.createElement('div');
    ph.className = 'task-drop-placeholder';
    dragState.placeholder = ph;
  }
  return dragState.placeholder;
}

function placeDragPlaceholder(targetRow, placeAfter) {
  const placeholder = getDragPlaceholder();
  if (!targetRow || !targetRow.parentElement) return;
  const parent = targetRow.parentElement;
  if (placeAfter) {
    parent.insertBefore(placeholder, targetRow.nextSibling);
  } else {
    parent.insertBefore(placeholder, targetRow);
  }
}

function clearDragVisuals() {
  if (dragState.placeholder && dragState.placeholder.parentElement) {
    dragState.placeholder.parentElement.removeChild(dragState.placeholder);
  }
  if (dragState.draggedRow) {
    dragState.draggedRow.classList.remove('task-dragging');
  }
}

function commitTaskReorder(fromIndex, toIndex) {
  if (fromIndex === null || toIndex === null) return;
  if (fromIndex < 0 || fromIndex >= tasks.length) return;
  if (toIndex < 0) toIndex = 0;
  if (toIndex > tasks.length - 1) toIndex = tasks.length - 1;
  if (fromIndex === toIndex) return;

  const activeTaskRef = current !== null ? tasks[current] : null;
  const [moved] = tasks.splice(fromIndex, 1);
  tasks.splice(toIndex, 0, moved);

  if (activeTaskRef) {
    current = tasks.indexOf(activeTaskRef);
  }
}

function resolveDropIndex() {
  const list = $('taskList');
  const placeholder = dragState.placeholder;
  if (!list || !placeholder || !placeholder.parentElement) return dragState.fromIndex;
  const children = Array.from(list.children);
  const placeholderPos = children.indexOf(placeholder);
  if (placeholderPos === -1) return dragState.fromIndex;

  let index = 0;
  for (let i = 0; i < placeholderPos; i++) {
    const el = children[i];
    if (el.classList.contains('task') && !el.classList.contains('task-dragging')) {
      index++;
    }
  }
  return index;
}

function resetDragState() {
  clearDragVisuals();
  dragState.active = false;
  dragState.fromIndex = null;
  dragState.draggedRow = null;
  dragState.pointerActive = false;
  dragState.pointerId = null;
  dragState.moved = false;
}

function finalizeDragDrop() {
  if (!dragState.active || dragState.fromIndex === null) {
    resetDragState();
    return;
  }
  const dropIndex = resolveDropIndex();
  const from = dragState.fromIndex;
  resetDragState();
  commitTaskReorder(from, dropIndex);
  render();
}

function onTaskDragStart(e, index, row) {
  if (!paused) {
    e.preventDefault();
    return;
  }
  dragState.active = true;
  dragState.fromIndex = index;
  dragState.draggedRow = row;
  row.classList.add('task-dragging');
  if (e.dataTransfer) {
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', String(index));
  }
}

function onTaskDragOver(e, row) {
  if (!dragState.active || !row || row === dragState.draggedRow) return;
  e.preventDefault();
  const rect = row.getBoundingClientRect();
  const placeAfter = (e.clientY - rect.top) > rect.height / 2;
  placeDragPlaceholder(row, placeAfter);
}

function onTaskDrop(e, row) {
  if (!dragState.active) return;
  e.preventDefault();
  if (row && row !== dragState.draggedRow) {
    const rect = row.getBoundingClientRect();
    const placeAfter = (e.clientY - rect.top) > rect.height / 2;
    placeDragPlaceholder(row, placeAfter);
  }
  finalizeDragDrop();
}

function onTaskDragEnd() {
  finalizeDragDrop();
}

function onTouchPointerMove(e) {
  if (!dragState.pointerActive || e.pointerId !== dragState.pointerId) return;
  const dx = e.clientX - dragState.startX;
  const dy = e.clientY - dragState.startY;
  if (!dragState.moved && Math.hypot(dx, dy) < 8) return;

  dragState.moved = true;
  dragState.active = true;
  suppressTaskClick = true;
  if (dragState.draggedRow) dragState.draggedRow.classList.add('task-dragging');

  const el = document.elementFromPoint(e.clientX, e.clientY);
  const row = el ? el.closest('.task') : null;
  if (row && row !== dragState.draggedRow) {
    const rect = row.getBoundingClientRect();
    const placeAfter = (e.clientY - rect.top) > rect.height / 2;
    placeDragPlaceholder(row, placeAfter);
  }
  e.preventDefault();
}

function onTouchPointerEnd(e) {
  if (!dragState.pointerActive || e.pointerId !== dragState.pointerId) return;
  document.removeEventListener('pointermove', onTouchPointerMove, { passive: false });
  document.removeEventListener('pointerup', onTouchPointerEnd);
  document.removeEventListener('pointercancel', onTouchPointerEnd);
  if (dragState.moved) {
    finalizeDragDrop();
  } else {
    resetDragState();
  }
}

function onTaskPointerDown(e, index, row) {
  if (!paused) return;
  if (e.pointerType === 'mouse') return;
  dragState.pointerActive = true;
  dragState.pointerId = e.pointerId;
  dragState.fromIndex = index;
  dragState.draggedRow = row;
  dragState.startX = e.clientX;
  dragState.startY = e.clientY;
  dragState.moved = false;
  document.addEventListener('pointermove', onTouchPointerMove, { passive: false });
  document.addEventListener('pointerup', onTouchPointerEnd);
  document.addEventListener('pointercancel', onTouchPointerEnd);
}

const fmt = (s) => {
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = s % 60;
  return `${h > 0 ? String(h).padStart(2, '0') + ':' : ''}${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
};

// Modal UI Logic

let smartTypedDigits = '';
const modalAddIcon = '<svg class="modal-mode-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>';
const modalEditIcon = '<svg class="modal-mode-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 20h4l10-10-4-4L4 16v4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="m12 6 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>';

function setSmartMaskFromDigits() {
  const full = smartTypedDigits.padStart(6, '0').slice(-6);
  const enteredCount = smartTypedDigits.length;
  const enteredFrom = 6 - enteredCount;
  const isDigitEntered = (digitIdx) => enteredCount > 0 && digitIdx >= enteredFrom;
  const isColonEntered = (colonPos) => {
    if (colonPos === 2) return enteredCount >= 4;
    return enteredCount >= 2;
  };
  const chars = [
    { ch: full[0], entered: isDigitEntered(0) },
    { ch: full[1], entered: isDigitEntered(1) },
    { ch: ':', entered: isColonEntered(2) },
    { ch: full[2], entered: isDigitEntered(2) },
    { ch: full[3], entered: isDigitEntered(3) },
    { ch: ':', entered: isColonEntered(5) },
    { ch: full[4], entered: isDigitEntered(4) },
    { ch: full[5], entered: isDigitEntered(5) }
  ];
  $('smartTimeMask').innerHTML = chars.map(c => `<span class="${c.entered ? 'entered' : 'placeholder'}">${c.ch}</span>`).join('');
  $('smartTimeInput').value = `${full.slice(0, 2)}:${full.slice(2, 4)}:${full.slice(4, 6)}`;
}

function setPulseRangeLabel() {
  const v = parseInt($('pulseRange').value, 10) || 0;
  $('pulseRangeLabel').textContent = v < 5 ? 'OFF' : `${v}m`;
}

$('pulseRange').oninput = setPulseRangeLabel;

// Smart Input
const timeInput = $('smartTimeInput');
timeInput.addEventListener('keydown', (e) => {
  if (e.key === 'Backspace') {
    e.preventDefault();
    smartTypedDigits = smartTypedDigits.slice(0, -1);
    setSmartMaskFromDigits();
  } else if (/^\d$/.test(e.key)) {
    e.preventDefault();
    if (smartTypedDigits.length < 6) {
      smartTypedDigits += e.key;
      setSmartMaskFromDigits();
    }
  } else if (e.key !== 'Tab') {
    e.preventDefault();
  }
});

timeInput.addEventListener('focus', () => {
  const len = timeInput.value.length;
  timeInput.setSelectionRange(len, len);
});
setSmartMaskFromDigits();
setPulseRangeLabel();

function timeToSeconds(str) {
  const p = str.split(':').map(x => parseInt(x) || 0);
  return (p[0] * 3600) + (p[1] * 60) + p[2];
}

function toggleSheet() {
  $('bottomSheet').classList.toggle('active');
  $('sheetOverlay').classList.toggle('active');
}

/// OPEN SHEET FUNCTION ///

function openSheet(type) {
  const title = $('sheetTitle'), body = $('sheetBody');
  if (type === 'focus') {
    title.textContent = "Focus Ratio";
    body.innerHTML = "Formula: <strong style='color:#fff'>focused time / total time</strong><br><br>Total time includes all pauses and gaps.";
  } else if (type === 'sidelined') {
    title.textContent = "Sidelined Time";
    body.innerHTML = "Tracks time where the session was running, but you were not working on a task (e.g., pauses or switching).";
  }
  toggleSheet();
}

function closeConfirm() { $('confirmEndOverlay').style.display = 'none'; }


$('endSessionBtn').onclick = () => {
  if (activePulse && !activePulse.answered) return;
  $('confirmEndOverlay').style.display = 'flex';
};
$('confirmEndBtn').onclick = () => { closeConfirm(); endSession(); };

function startTaskRun() {
  if (current === null || !tasks[current]) return;
  if (!paused) return;
  sessionActive = true;
  taskRunning = true;
  paused = false;
  $('stateText').textContent = 'Running';
  if (!sessionStartTimestamp) sessionStartTimestamp = Date.now();

  if (!tasks[current].log.length) {
    tasks[current].log.push({ type: 'START', time: Date.now() });
  } else {
    tasks[current].log.push({ type: 'RESUME', time: Date.now() });
  }
  lastTickAt = Date.now();
  tick = setInterval(() => {
    tasks[current].spent++;
    totalFocusedSeconds++;
    $('countdown').textContent = fmt(Math.max(0, tasks[current].est - tasks[current].spent));
    $('stopwatch').textContent = fmt(tasks[current].spent);
    const focusStop = $('focusStopwatchMain');
    const focusRem = $('focusRemainingSub');
    if (focusStop && taskRunning) {
      focusStop.textContent = $('stopwatch').textContent;
    }
    if (focusRem) {
      focusRem.textContent = `remaining ${$('countdown').textContent}`;
    }
  }, 1000);
  startPulseScheduler();
  if (tasks[current].pauseStartedAt) {
    tasks[current].pauses += Math.floor(
      (Date.now() - tasks[current].pauseStartedAt) / 1000
    );
    tasks[current].pauseStartedAt = null;
  }
  render();
}

function pauseTaskRun() {
  if (current === null || paused) return;
  taskRunning = false;
  paused = true;
  clearInterval(tick);
  $('stateText').textContent = 'Paused';
  tasks[current].log.push({ type: 'PAUSE', time: Date.now() });
  tasks[current].pauseStartedAt = Date.now();
  clearPulseForTransition();
  render();
}

const lockSwipe = {
  active: false,
  pointerId: null,
  startX: 0,
  startLeft: 0
};

function getLockParts() {
  const wrap = $('focusLockSwitch');
  if (!wrap) return null;
  const track = wrap.querySelector('.focus-lock-track');
  const knob = wrap.querySelector('.focus-lock-knob');
  const input = $('focusLockToggle');
  if (!track || !knob || !input) return null;
  const min = 8;
  const max = track.clientWidth - knob.offsetWidth - 8;
  return { wrap, track, knob, input, min, max };
}

function onLockPointerDown(e) {
  const parts = getLockParts();
  if (!parts) return;
  if (!e.target.closest('.focus-lock-track')) return;
  lockSwipe.active = true;
  lockSwipe.pointerId = e.pointerId;
  lockSwipe.startX = e.clientX;
  lockSwipe.startLeft = parseFloat(getComputedStyle(parts.knob).left) || (parts.input.checked ? parts.max : parts.min);
  parts.knob.style.transition = 'none';
  parts.wrap.setPointerCapture(e.pointerId);
  e.preventDefault();
}

function onLockPointerMove(e) {
  if (!lockSwipe.active || e.pointerId !== lockSwipe.pointerId) return;
  const parts = getLockParts();
  if (!parts) return;
  const dx = e.clientX - lockSwipe.startX;
  const left = Math.max(parts.min, Math.min(parts.max, lockSwipe.startLeft + dx));
  parts.knob.style.left = `${left}px`;
  e.preventDefault();
}

function onLockPointerEnd(e) {
  if (!lockSwipe.active || e.pointerId !== lockSwipe.pointerId) return;
  const parts = getLockParts();
  lockSwipe.active = false;
  lockSwipe.pointerId = null;
  if (!parts) return;
  parts.wrap.releasePointerCapture(e.pointerId);
  parts.knob.style.transition = '';

  const dx = e.clientX - lockSwipe.startX;
  const swipeThreshold = Math.max(24, (parts.max - parts.min) * 0.18);
  const committed = Math.abs(dx) >= swipeThreshold;
  const wantsLocked = committed ? dx > 0 : parts.input.checked;
  parts.knob.style.left = '';

  if (wantsLocked && paused) {
    startTaskRun();
    return;
  }
  if (!wantsLocked && !paused) {
    pauseTaskRun();
    return;
  }
  render();
}

$('focusLockSwitch')?.addEventListener('pointerdown', onLockPointerDown);
document.addEventListener('pointermove', onLockPointerMove, { passive: false });
document.addEventListener('pointerup', onLockPointerEnd);
document.addEventListener('pointercancel', onLockPointerEnd);

$('focusCompleteBtn').onclick = () => {
  completeTaskWithFocusAnimation();
};

$('focusManageBtn').onclick = () => {
  if (taskRunning) {
    setScreen('focus');
  } else {
    setScreen('manage');
  }
  render();
};


/// FIRE PULSE FUNCTION ///

function firePulse(task) {
  const now = Date.now();

  if (!sessionActive || !taskRunning || paused) return;
  if (isOverlayVisible('confirmEndOverlay') || isOverlayVisible('taskTimelineOverlay') || isOverlayVisible('resultsOverlay')) return;
  if (activePulse && activePulse.answered) {
    if (activePulse.timeout) { clearTimeout(activePulse.timeout); activePulse.timeout = null; }
    if (activePulse.colorTimer) { clearInterval(activePulse.colorTimer); activePulse.colorTimer = null; }
    activePulse = null;
  }
  if (activePulse && !activePulse.answered) {
    return; // don't stack pulses
  }

  const taskIndex = tasks.indexOf(task);
  if (taskIndex === -1) return;

  const pulseEntry = {
    task: task.text,
    taskIndex,
    time: now,
    answered: false
    
  };
  activePulse = pulseEntry;


  pulseLog.push(pulseEntry);

  task.log.push({
    type: 'PULSE',
    time: now,
    answered: false
  });
  pulseEntry.logIndex = task.log.length - 1;

  // In-app pulse popup
  if (document.visibilityState === 'visible') {
    showPulsePopup(pulseEntry);
  } else if ("Notification" in window && Notification.permission === "granted") {
    new Notification("Lock-In Check", {
      body: "You there?",
      tag: "lockin-pulse",
      silent: true
    });
  }

  lastPulseAt = now;

  pulseEntry.timeout = setTimeout(() => {
  if (!pulseEntry.answered) {
    failPulse(pulseEntry);
    }
  }, 60 * 1000);

}

/// SHOW PULSE POPUP FUNCTION ///

function showPulsePopup(pulseEntry) {
  const popup = $('pulsePopup');
  const card = $('pulseTapCard');
  const fillLayer = $('pulseFillLayer');

  popup.style.display = 'flex';
  if (fillLayer) {
    fillLayer.classList.remove('active');
    void fillLayer.offsetWidth;
    fillLayer.classList.add('active');
  }

  const pulseStart = pulseEntry.time;

  // initial color
  updatePulseColor(pulseStart);

  // update color every second
  pulseEntry.colorTimer = setInterval(() => {
    updatePulseColor(pulseStart);
  }, 1000);

  card.onclick = () => {
    clearInterval(pulseEntry.colorTimer);
    answerPulse(pulseEntry);
  };
}


/// PULSE COLOR FUNCTION ///

function updatePulseColor(startTime) {
  const elapsed = Math.floor((Date.now() - startTime) / 1000);
  const card = $('pulseTapCard');

  card.classList.remove('pulse-green', 'pulse-yellow', 'pulse-orange', 'pulse-red');

  if (elapsed < 10) {
    card.classList.add('pulse-green');
  } else if (elapsed < 30) {
    card.classList.add('pulse-yellow');
  } else if (elapsed < 45) {
    card.classList.add('pulse-orange');
  } else {
    card.classList.add('pulse-red');
  }
}


/// ANSWER PULSE FUNCTION ///

function answerPulse(pulseEntry) {
  pulseEntry.answered = true;
  if (pulseEntry.timeout) { clearTimeout(pulseEntry.timeout); pulseEntry.timeout = null; }
  if (pulseEntry.colorTimer) { clearInterval(pulseEntry.colorTimer); pulseEntry.colorTimer = null; }
  activePulse = null;

  const task = tasks[pulseEntry.taskIndex];
  if (task && task.log[pulseEntry.logIndex] && task.log[pulseEntry.logIndex].type === 'PULSE') {
    task.log[pulseEntry.logIndex].answered = true;
  }

  $('pulsePopup').style.display = 'none';
  $('pulseFillLayer')?.classList.remove('active');
  $('app')?.classList.remove('blurred');
  startPulseScheduler();
}

/// FAIL PULSE FUNCTION ///

function failPulse(pulseEntry) {
  if (pulseEntry.answered) return;
  pulseEntry.answered = false;
  if (pulseEntry.timeout) { clearTimeout(pulseEntry.timeout); pulseEntry.timeout = null; }
  if (pulseEntry.colorTimer) { clearInterval(pulseEntry.colorTimer); pulseEntry.colorTimer = null; }
  activePulse = null;

  const task = tasks[pulseEntry.taskIndex];
  if (!task) return;

  // mark pulse as failed in task log
  if (task.log[pulseEntry.logIndex] && task.log[pulseEntry.logIndex].type === 'PULSE') {
    task.log[pulseEntry.logIndex].failed = true;
  }

  // add 60s sidelined time
  task.pauses += 60;

  // close popup + unblur if visible
  $('pulsePopup').style.display = 'none';
  $('pulseFillLayer')?.classList.remove('active');
  $('app')?.classList.remove('blurred');
  startPulseScheduler();
}

function focusStopwatchText() {
  if (current === null || !tasks[current]) return '00:00';
  return $('stopwatch').textContent || fmt(tasks[current].spent);
}

function focusRemainingText() {
  if (current === null || !tasks[current]) return '00:00';
  return $('countdown').textContent || fmt(Math.max(0, tasks[current].est - tasks[current].spent));
}

function renderFocusStack() {
  const stack = $('focusStack');
  stack.innerHTML = '';

  if (tasks.length === 0 || current === null || !tasks[current]) {
    const empty = document.createElement('div');
    empty.className = 'focus-item focus-item-current';
    empty.innerHTML = `<div class="focus-current-task">No Active Task</div>`;
    stack.appendChild(empty);
    return;
  }

  const startPrev = Math.max(0, current - 2);
  for (let i = startPrev; i < current; i++) {
    const row = document.createElement('div');
    row.className = 'focus-item focus-item-prev';
    row.textContent = tasks[i].text;
    stack.appendChild(row);
  }

  const currentRow = document.createElement('div');
  currentRow.className = 'focus-item focus-item-current';
  currentRow.dataset.taskIndex = String(current);
  currentRow.innerHTML = `<div class="focus-current-task">${tasks[current].text}</div>`;
  stack.appendChild(currentRow);

  const endNext = Math.min(tasks.length - 1, current + 2);
  for (let i = current + 1; i <= endNext; i++) {
    const row = document.createElement('div');
    row.className = 'focus-item focus-item-next';
    row.textContent = tasks[i].text;
    stack.appendChild(row);
  }
}

function renderFocusActions() {
  $('focusLockToggle').checked = taskRunning === true;
  $('focusLockToggle').disabled = current === null;
  $('focusCompleteBtn').disabled = current === null || completionInFlight;

  const manageBtn = $('focusManageBtn');
  if (!manageBtn) return;
  const visible = paused === true;
  manageBtn.classList.toggle('is-visible', visible);
  manageBtn.classList.toggle('is-hidden', !visible);
}

function completeTaskFlow() {
  if (current === null) return;

  if (!paused) {
    taskRunning = false;
    paused = true;
    clearInterval(tick);
    $('stateText').textContent = 'Paused';
  }

  clearPulseForTransition();
  const activeTask = tasks[current];
  if (completionPendingEndEntry && completionPendingEndTaskIndex === current) {
    const endIdx = activeTask.log.indexOf(completionPendingEndEntry);
    if (endIdx !== -1) {
      delete activeTask.log[endIdx].pendingComplete;
    } else {
      activeTask.log.push({ type: 'END', time: Date.now() });
    }
  } else {
    activeTask.log.push({ type: 'END', time: Date.now() });
  }
  completionPendingEndEntry = null;
  completionPendingEndTaskIndex = null;
  tasks[current].done = true;

  resetPulseScheduler();

  if (tasks.every(t => t.done)) {
    pendingSessionEnd = true;
  }

  const next = tasks.findIndex(t => !t.done);
  current = next !== -1 ? next : null;
  completionInFlight = false;
  $('focusCompleteWrap')?.classList.remove('focus-complete-firing');

  render();

  if (pendingSessionEnd) {
    pendingSessionEnd = false;
    endSession();
  }
}

function animateStackCompletionAndCommit() {
  const stack = $('focusStack');
  const currentItem = stack ? stack.querySelector('.focus-item-current') : null;
  const nextItems = stack ? Array.from(stack.querySelectorAll('.focus-item-next')) : [];
  const nextItem = nextItems.length ? nextItems[0] : null;
  const trailingNextItems = nextItems.slice(1);
  const prevItems = stack ? stack.querySelectorAll('.focus-item-prev') : [];

  if (!stack || !currentItem) {
    completeTaskFlow();
    return;
  }

  let finished = false;
  const finish = () => {
    if (finished) return;
    finished = true;
    stack.classList.remove('completing');
    currentItem.classList.remove('focus-item-complete-out');
    if (nextItem) nextItem.classList.remove('focus-item-promote');
    prevItems.forEach(el => el.classList.remove('focus-item-shift-up'));
    trailingNextItems.forEach(el => el.classList.remove('focus-item-next-shift'));
    completeTaskFlow();
  };

  const onTransitionEnd = (e) => {
    if (e.target !== currentItem || e.propertyName !== 'transform') return;
    finish();
  };

  currentItem.addEventListener('transitionend', onTransitionEnd, { once: true });
  stack.classList.add('completing');
  currentItem.classList.add('focus-item-complete-out');
  if (nextItem) nextItem.classList.add('focus-item-promote');
  prevItems.forEach(el => el.classList.add('focus-item-shift-up'));
  trailingNextItems.forEach(el => el.classList.add('focus-item-next-shift'));
  setTimeout(finish, 360);
}

function completeTaskWithFocusAnimation() {
  if (current === null) return;
  if (completionInFlight) return;
  if (activePulse && !activePulse.answered) return;
  if (!paused) {
    pauseTaskRun();
  }
  const task = tasks[current];
  completionPendingEndEntry = { type: 'END', time: Date.now(), pendingComplete: true };
  completionPendingEndTaskIndex = current;
  task.log.push(completionPendingEndEntry);
  completionInFlight = true;
  timelineMode = 'complete';
  timelineTaskIndex = current;
  openTaskTimeline(current, 'complete');
}


/// RENDER FUNCTION ///

function render() {
  syncScreenRoute();
  clearDragVisuals();
  const list = $('taskList'); list.innerHTML = '';
  tasks.forEach((t, i) => {
    const d = document.createElement('div');
    d.className = 'task' + (i === current ? ' selected' : '') + (t.done ? ' done' : '');
    d.onclick = () => {
      if (suppressTaskClick) {
        suppressTaskClick = false;
        return;
      }
      if (!t.done && paused) { clearPulseForTransition(); current = i; render(); }
    };
    
    const content = document.createElement('div');
    content.className = 'task-content';
    content.innerHTML = `<b>${t.text}</b>${t.mode ? `<br><small style="font-size:11px; color:var(--muted); opacity:0.75">${t.mode}</small>` : ''}`;
    d.appendChild(content);

    if (!t.done && paused) {
      const eb = document.createElement('button');
      eb.innerHTML = '<svg class="ui-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 20h4l10-10-4-4L4 16v4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="m12 6 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>';
      eb.style.cssText = "background:transparent; border:none; display:flex; align-items:center; justify-content:center;";
      eb.onclick = (e) => { e.stopPropagation(); openEdit(i); };
      d.appendChild(eb);
    }

    if (paused) {
      d.draggable = true;
      d.addEventListener('dragstart', (e) => onTaskDragStart(e, i, d));
      d.addEventListener('dragover', (e) => onTaskDragOver(e, d));
      d.addEventListener('drop', (e) => onTaskDrop(e, d));
      d.addEventListener('dragend', onTaskDragEnd);
      d.addEventListener('pointerdown', (e) => onTaskPointerDown(e, i, d));
    } else {
      d.draggable = false;
    }

    list.appendChild(d);
  });
  if (current !== null) {
    $('countdown').textContent = fmt(Math.max(0, tasks[current].est - tasks[current].spent));
    $('stopwatch').textContent = fmt(tasks[current].spent);
  } else {
    $('countdown').textContent = '00:00:00';
    $('stopwatch').textContent = '00:00:00';
  }
  $('addWrapper').style.display = (paused || current === null) ? 'flex' : 'none';
  $('timerGrid').style.display = (current !== null) ? 'block' : 'none';
  $('endSessionBtn').disabled = !sessionStartTimestamp;
  $('endSessionBtn').style.opacity = sessionStartTimestamp ? '1' : '0.45';
  $('endSessionBtn').style.pointerEvents = sessionStartTimestamp ? 'auto' : 'none';
  $('actionButtons').style.display = 'flex';
  $('startBtn').textContent = 'enter session';
  $('startBtn').disabled = current === null;
  $('startBtn').style.opacity = current === null ? '0.45' : '1';
  $('startBtn').style.pointerEvents = current === null ? 'none' : 'auto';
  renderFocusStack();
  $('focusStopwatchMain').textContent = focusStopwatchText();
  $('focusRemainingSub').textContent = `remaining ${focusRemainingText()}`;
  renderFocusActions();
}

/// OPEN TASK TIMELINE FUNCTION ///

function openTaskTimeline(index, mode = 'view') {
  if (activePulse && !activePulse.answered) {
    completionInFlight = false;
    $('focusCompleteWrap')?.classList.remove('focus-complete-firing');
    return;
  }
  timelineMode = mode;
  timelineTaskIndex = index;
  const t = tasks[index];
  const tbody = $('taskTimelineTable').querySelector('tbody');
  tbody.innerHTML = '';
  const confirmBtn = $('confirmTaskTimelineBtn');
  const backBtn = $('backTaskTimelineBtn');
  confirmBtn.textContent = mode === 'complete' ? 'Confirm' : 'Close';
  backBtn.style.display = mode === 'complete' ? 'block' : 'none';

  t.log.forEach((e, i) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${e.type}</td>
      <td>${new Date(e.time).toLocaleTimeString()}</td>

      <td>${e.type === 'PULSE'? `<input type="checkbox" ${e.answered ? 'checked' : ''} onchange="this.checked ? (tasks[${index}].log[${i}].answered = true) : (tasks[${index}].log[${i}].answered = false)">`: '-'}</td>
    `;

    tbody.appendChild(tr);
  });

  $('taskTimelineOverlay').style.display = 'flex';

  backBtn.onclick = () => {
    $('taskTimelineOverlay').style.display = 'none';
    if (timelineMode === 'complete' && completionPendingEndEntry && completionPendingEndTaskIndex !== null) {
      const backTask = tasks[completionPendingEndTaskIndex];
      if (backTask) {
        const pendingIdx = backTask.log.indexOf(completionPendingEndEntry);
        if (pendingIdx !== -1) {
          backTask.log.splice(pendingIdx, 1);
        }
      }
      completionPendingEndEntry = null;
      completionPendingEndTaskIndex = null;
    }
    completionInFlight = false;
    $('focusCompleteWrap')?.classList.remove('focus-complete-firing');
    renderFocusActions();
  };

  confirmBtn.onclick = () => {
    $('taskTimelineOverlay').style.display = 'none';

    if (timelineMode === 'complete') {
      $('focusCompleteWrap')?.classList.add('focus-complete-firing');
      animateStackCompletionAndCommit();
      return;
    }

    render();
  };
}

$('openAddModalBtn').onclick = () => {
  editingIndex = null;
  $('modalTitle').innerHTML = modalAddIcon;
  $('modalTaskName').value = ""; 
  smartTypedDigits = '';
  setSmartMaskFromDigits();
  $('workModeSelect').value = '';
  $('pulseRange').value = '0';
  setPulseRangeLabel();
  $('editorActionsRow').classList.remove('edit-mode');
  $('editorActionsRow').classList.add('add-mode');
  $('deleteTaskBtn').classList.remove('is-enabled');
  $('deleteTaskBtn').classList.add('is-disabled');
  $('deleteTaskBtn').disabled = true;
  $('taskEditorOverlay').style.display = 'flex';
};

/// OPEN EDIT FUNCTION ///

function openEdit(index) {
  editingIndex = index;
  const t = tasks[index];
  $('modalTitle').innerHTML = modalEditIcon;
  $('modalTaskName').value = t.text;
  const h = Math.floor(t.est/3600), m = Math.floor((t.est%3600)/60), s = t.est%60;
  smartTypedDigits = `${String(h).padStart(2,'0')}${String(m).padStart(2,'0')}${String(s).padStart(2,'0')}`.slice(-6);
  setSmartMaskFromDigits();
  $('workModeSelect').value = t.mode || '';
  const pulseVal = (t.pulse || 0) < 5 ? 0 : Math.max(5, Math.min(15, t.pulse || 0));
  $('pulseRange').value = String(pulseVal);
  setPulseRangeLabel();
  $('editorActionsRow').classList.remove('add-mode');
  $('editorActionsRow').classList.add('edit-mode');
  $('deleteTaskBtn').classList.remove('is-disabled');
  $('deleteTaskBtn').classList.add('is-enabled');
  $('deleteTaskBtn').disabled = false;
  $('taskEditorOverlay').style.display = 'flex';
}

/// DELETE TASK FUNCTION ///

$('deleteTaskBtn').onclick = () => {
  if (editingIndex !== null) {
    tasks.splice(editingIndex, 1);
    if (current === null && tasks.length) {
      current = tasks.findIndex(t => !t.done);
    }
    $('taskEditorOverlay').style.display = 'none';
    render();
  }
};

/// SAVE TASK FUNCTION ///

$('saveTaskBtn').onclick = () => {
  const name = $('modalTaskName').value.trim(), timeStr = $('smartTimeInput').value;
  if (!name || timeToSeconds(timeStr) <= 0) return;
  const mode = $('workModeSelect').value;
  const pulseRaw = parseInt($('pulseRange').value, 10) || 0;
  const pulse = pulseRaw < 5 ? 0 : Math.max(5, Math.min(15, pulseRaw));
  
  if (editingIndex === null) {
    tasks.push({ text: name, est: timeToSeconds(timeStr), spent: 0, done: false, log: [], pauses: 0,pauseStartedAt: null, mode, pulse });
  } else {
    tasks[editingIndex].text = name; 
    tasks[editingIndex].est = timeToSeconds(timeStr);
    tasks[editingIndex].mode = mode;
    tasks[editingIndex].pulse = pulse;
  }
  $('taskEditorOverlay').style.display = 'none'; 
  render();
};

$('cancelEditor').onclick = () => { $('taskEditorOverlay').style.display = 'none'; };

/// START BUTTON FUNCTION ///

$('startBtn').onclick = () => {
  if (current === null) return;
  sessionActive = true;
  taskRunning = false;
  paused = true;
  clearInterval(tick);
  resetPulseScheduler();
  $('stateText').textContent = 'Idle';
  setScreen('focus');
  render();
};

/// COMPLETE BUTTON FUNCTION ///

if ($('completeBtn')) {
  $('completeBtn').onclick = () => {
    completeTaskWithFocusAnimation();
  };
}

/// END SESSION FUNCTION ///

function endSession() {
  completionInFlight = false;
  completionPendingEndEntry = null;
  completionPendingEndTaskIndex = null;
  $('focusCompleteWrap')?.classList.remove('focus-complete-firing');
  clearPulseForTransition();
  clearInterval(tick);
  paused = true;
  taskRunning = false;
  sessionActive = false;
  sessionEndTimestamp = Date.now();
  if (!sessionStartTimestamp) sessionStartTimestamp = sessionEndTimestamp;
  const total = Math.floor((sessionEndTimestamp - sessionStartTimestamp) / 1000);
  const ratio = total > 0 ? Math.round((totalFocusedSeconds / total) * 100) : 0;
  $('resTotal').textContent = fmt(total);
  $('resFocused').textContent = fmt(totalFocusedSeconds);
  $('resPaused').textContent = fmt(Math.max(0, total - totalFocusedSeconds));
  $('resRatio').textContent = ratio + '%';
  const tbody = $('resBreakdown').querySelector('tbody');
  tbody.innerHTML = '';

  tasks.forEach((t, i) => {
    const total = t.spent + (t.pauses || 0);
    const tr = document.createElement('tr');
    tr.style.cursor = 'pointer';
    tr.innerHTML = `
     <td>${t.text}</td>
      <td>${t.mode || '-'}</td>
      <td>${fmt(t.pauses || 0)}</td>
      <td>${fmt(t.spent)}</td>
      <td>${fmt(total)}</td>
    `;
    tr.onclick = () => openTaskTimeline(i);
    tbody.appendChild(tr);
  });
  

  $('resultsOverlay').style.display = 'flex';
}

$('closeStatsBtn').onclick = () => {
  tasks = [];
  current = null;
  sessionStartTimestamp = null;
  totalFocusedSeconds = 0;
  sessionActive = false;
  taskRunning = false;
  completionInFlight = false;
  completionPendingEndEntry = null;
  completionPendingEndTaskIndex = null;
  $('focusCompleteWrap')?.classList.remove('focus-complete-firing');
  $('resultsOverlay').style.display = 'none';
  render();
};

render();
</script>


</body>
</html>
